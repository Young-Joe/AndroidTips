## Java基础

##### java内存分配策略

java程序运行时的内存分配策略有三种,分别是静态分配,栈式分配,和堆式分配.

|              |    内存空间    |            存储内容             | 创建时机  | 回收时机                |
| :----------: | :--------: | :-------------------------: | ----- | ------------------- |
|     静态分配     | 静态存储区(方法区) | 静态数据.全局static数据和常量(final修饰) | 程序编译时 | 程序整个运行期间            |
|     栈式分配     |     栈区     |   方法内的局部变量(基础数据类型.对象的引用)    | 方法执行时 | 方法结束时自动释放           |
| 堆式分配(动态内存分配) |     堆区     |     直接new出来的内存,也就是对象的实例     | 程序运行时 | 该部分内存不使用时由java垃圾回收器 |

成员变量全部存储与堆中(基本数据类型,引用和引用的对象实体)

##### java内存管理

java的内存管理就是对象的分配和释放问题.

在java中,需要通过关键字new为每个对象申请内存空间(基本类型除外),所以的对象都在堆(Heap)中分配空间.对象的释放是由GC决定和执行的.GC为了能够正确释放对象,GC必须监控每一个对象的运行状态,包括对象的申请.引用.被引用.赋值等.

监控对象状态是为了更加准确地,及时地释放对象,而释放对象的根本原则就是该对象不再被引用.

##### JVM内存模式

栈.堆.方法区.本地方法区.程序计数器

##### ThreadLocal

ThreadLocal的作用是提供线程内的局部变量,这种变量在线程的生命周期内起作用,减少同一个线程内多个函数或组件之间一些公共变量的传递的复杂度.每个Thread维护一个ThreadLocalMap映射表,这个映射表的key是ThreadLocal实例本身,value是真正需要存储的Object

参考:[ThreadLocal理解](https://www.zhihu.com/question/23089780)

#### java类加载过程：

- 1.加载时机：创建实例、访问静态变量或方法、反射、加载子类之前
- 2.验证：验证文件格式、元数据、字节码、符号引用的正确性
- 3.加载：根据全类名获取文件字节流、将字节流转化为静态储存结构放入方法区、生成class对象
- 4.准备：在堆上为静态变量划分内存
- 5.解析：将常量池中的符号引用转换为直接引用
- 6.初始化：初始化静态变量

##### 禁止在foreach循环内进行元素的remove/add 

也称增强for循环.是java提供的一个语法糖.内部依赖了while循环和Iterator.

早foreach中进行remove/add会抛出fail-fast.快速失败(`java集合的一种错误检测机制`).集合遍历通过iterator进行,但是元素的remove/add却是直接使用的集合类自己的方法,这就导致iterator在遍历的时候会发现一个元素在自己不知不觉的情况下就被删除/添加了,就会抛出fail-fast.

static静态块先运行，随后才运行构造方法！运行主方法的话，也是先运行static代码块，再运行主方法。